# 理解算法的空间换时间

## 求和

对于给定数列array长度为n，给定任意两数x，y求array\[x]至array\[y]的和。 (0 \< x \< y \< n)

直接对数组求和，复杂度为$\theta(n)$。

### 多次求和

对于上面的求和操作重复进行q次，如果不改变算法复杂度为$\theta(qn)$。

我们很快就能想出一种优化方式，构造新数列$newArray(length = n)$,
使$newArray[n] = newArray[n-1] + array[n]$，或者说

$$
newArray[n] = \sum_1^n array[i]
$$

那么对于每次查询(0 \< x \< y \< n)，只需要计算$newArray[y] - newArray[x]$便可得出答案。此方法

这里我们使用了空间换时间的策略，即使用一个新的数组存放预先计算的和，然后通过一次减法操作得出答案。

### 单点修改，范围求和

但是大多数情况下，数据不是一成不变的。

如果在基于上面例子上，我们会在多次查询中间插入若干次单点数据的修改，整个新数组将会耗用$\theta(n)$复杂度的时间进行重新更新。对于查询次数远大于单点数据的插入时，对整个数据进行更新还是相对划算的。

然而当查询和插入的次数相差的并没有如此悬殊，再简单地将新数组定义成$\sum_1^n array[i]$已经不合适了。如何构造新的数组使每次单点修改时间复杂度减少呢？

可以发现，由于新构造的newArray，我们称之为预计算数组，的后面的项是它对应到原数组$1-n$的和，所以越靠近前面的数单点数据修改，对整个预计算数组的影响越大。

那如果只记录$0-n/2$的结果，即对于$0 < m < n$，分为两段预计算数组，前一段是$\sum_1^m array[i]$，后一段时$\sum_m^n array[i]$，那么每一次改动最多造成的数据变动最多为$\theta(n/2)$。

此时如果需要区间[x, y]的结果，则转化为算[x, m] + [m, y]的结果。同时为了算出这个结果，我们比之前多算了一次，而一次改动则减少了一半的修改。

根据查找和修改的比例，可以将原数组分成任意数量段，那么修改和查询耗用时间之和将会趋于一个平衡。朴素地将数据按段分，再在每一段数据做单纯地求和是一种方法，但是接下来要介绍的是另一种更优美的分割方法，树状数组。
