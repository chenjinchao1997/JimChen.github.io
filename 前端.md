# mianshi

## 计网

**TCP三次**
b: seq:x syn:1
s: seq:y ack:x+1 syn:1
b: ack:y+1 seq:z

**TCP与UDP基本区别**

1. 基于连接与无连接
2. TCP要求系统资源较多，UDP较少
3. UDP程序结构较简单
4. 流模式（TCP）与数据报模式(UDP)
5. TCP保证数据正确性，UDP可能丢包
6. TCP保证数据顺序，UDP不保证

**HTTP1** **HTTP1.1** **HTTP2** **Websocket** 区别

1。0是每个请求分别做一次tcp连接，但是1.1会对单个tcp连接进行服用，Connection: keep-alive，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。但是1.1仍然是串行的，即使前端发送不串行后端返回也是串行（1.1Pipeling）

2.0是多路复用，用id区分，且完全兼容1.1。帧，stream，首部压缩等

## 底层

html **语义化意义**

1. 有利于SEO，有利于搜索引擎爬虫更好的理解我们的网页，从而获取更多的有效信息，提升网页的权重。
2. 在没有CSS的时候能够清晰的看出网页的结构，增强可读性。
3. 便于团队开发和维护，语义化的HTML可以让开发者更容易的看明白，从而提高团队的效率和协调能力。
4. 支持多终端设备的浏览器渲染。

**浏览器请求开始过程**

1. DNS
2. TCP
3. HTTP
4. 接收响应
5. 解析html（预加载器）
6. 布局渲染

**闭包** 当内部函数被作用域外引用的时候，就创建了一个闭包。
闭包让一个函数的活动对象不被释放，这样的话，函数内部所有的变量将不会消失

```javascript
function a() {
 var i = 0;
 function b() { alert(++i); }
 return b;
}
var c = a();
c();

var Counter = (function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  }   
})();
```

**重绘 重排**
**重绘**是一个 **元素外观** 的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。

**重排**是更明显的一种改变，可以理解为渲染树需要重新计算。下面是常见的触发重排的操作：
1. DOM元素的几何属性变化
2. DOM树的结构变化 如果在body最前面插入一个元素，会导致整个文档的重新渲染，而在其后插入一个元素，则不会影响到前面的元素。
3. 获取某些属性 当获取一些属性时，浏览器为取得正确的值也会触发重排。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。
4. 改变浏览器窗口大小

优化重排：
1. 不要一条条修改DOM
2. DOM离线修改(display: none) documentFragment clone
3. postion fixed absolute

**基本类型** Number、Boolean、String、NULL、Undefined
以及ES6的Symbol
Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）
2 引用类型
Object、Array、Function、Date
2、在内存中位置的不同
基本类型：占用空间固定，保存在栈中；
引用类型：占用空间不固定，保存在堆中；

**作用域链**


**事件冒泡** **事件捕获**

**原型链**
每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。

几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。

**new**
new一个对象的过程
1. 创建空对象
2. 设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象
　　obj.__proto__ = ClassA.prototype;
3. 使用新对象调用函数，函数中的this被指向新实例对象
　　ClassA.call(obj);　　//{}.构造函数();
4. 将初始化完毕的新对象地址，保存到等号左边的变量中
若构造函数中返回this或返回值是基本类型（number、string、boolean、null、undefined）的值，则返回新实例对象；若返回值是引用类型的值，则实际返回值为这个引用类型。

**Promise实现**
```javascript
const RESOLVED = 'resolved'
const PENDING = 'pending'

function MyPromise(fn) {
    this.status = PENDING
    this.value = null
    this.error = null
    this.resolveCB = v => v

    const _resolve = (value) => {
        if(value instanceof MyPromise) {
            return value.then(_resolve);
        }
        this.status = RESOLVED
        this.value = value
        this.resolveCB(this.value)
    }

    fn(_resolve)
}

MyPromise.prototype.then = function(onfulfilled) {
    let that = this
    if (that.status === PENDING) {
        return new MyPromise(resolve => {
            that.resolveCB = (val) => {
                resolve(onfulfilled(val))
            }
        })
    } else if (that.status === RESOLVED) {
        let result = onfulfilled(that.value)
        if (result instanceof MyPromise) {
            return result
        } else {
            return new MyPromise(resolve => {
                resolve(that.value)
            })
        }
    }
}

let p = new MyPromise((resolve, reject) => {
    setTimeout(() => {
        console.log(100)
        resolve(100)
    }, 1000)
}).then(value => new MyPromise((resolve, reject) => {
        setTimeout(() => {
            console.log(value + 1)
            resolve(value + 1)
        }, 1000)
    })
).then(value => console.log(value + 1))
```

**EventLoop** JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

1.所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
2.主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
3.一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
4.主线程不断重复上面的第三步。
浏览器的event loop至少包含两个队列，macrotask队列和microtask队列 ？？？

**javascript内存模型**
Array 数据在哪？

# ES6

Symbol

class

Proxy reflect

## 安全

XSS 攻击 前端接收到后端的有毒数据 （escapeHTML）

XSS，即 Cross Site Script，中译是跨站脚本攻击；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。

XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。

攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。

CSRF（Cross-site request forgery）跨站请求伪造
X-Content-Type-Options 利用请求内容推断实际上运行了script

## vue

原理

mvvm主要包含两个方面，数据变化更新视图，视图变化更新数据
Object.defineProperty 得知 数据变化 视图事件触发数据改变

diff 算法

钩子

## vue-router

## koa

原理

## 其他

**防抖（debounce）**
所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

```javascript
function debounce(func, wait) {
    let timeout;
    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);

        timeout = setTimeout(() => {
            func.apply(context, args)
        }, wait);
    }
}
```

**节流（throttle）**
所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。

```javascript
function throttle(func, wait) {
    let timeout;
    return function() {
        let context = this;
        let args = arguments;
        if (!timeout) {
            func.apply(context, args)
            timeout = setTimeout(() => {
                timeout = null;
            }, wait)
        }

    }
}
```

## 如何使得函数执行报错 new不报错

function p () {
    if (!(this instanceof p)) throw new Error('no')
    this.info = {}
}

## bind

Function.prototype.bind = function(context){
  var args = Array.prototype.slice.call(arguments, 1),
  self = this;
  return function(){
      var innerArgs = Array.prototype.slice.call(arguments);
      var finalArgs = args.concat(innerArgs);
      return self.apply(context,finalArgs);
  };
};

## JavaScript基础

function Peo () {
    this.a = 123
    return 'hello'
}
var a = new Peo();

function Peo () {
    this.a = 123
    return {}
}
var a = new Peo();

===========

window.name = 'ByteDance';
function A () {
   this.name = 123;
}
A.prototype.getA = function(){
    console.log(this);
    return this.name + 1;
}
let a = new A();
let funcA = a.getA;
console.log(funcA());

==========
var func1 = x => x;
var func2 = x => {x};
var func3 = x => ({x});
console.log(func1(1));
console.log(func2(1));
console.log(func3(1));

========

for (var i = 0; i < 6; i++) { // var改为let
    setTimeout(function() {
        console.log(new Date, i);
    }, 1000);
}

### css

CSS中，除了默认的流定位方式以外，还有如下几种定位机制：浮动定位、相对定位、绝对定位和固定定位。

浮动定位是将元素排除在普通流之外，并且将它放置在包含框的左边或者右边，但是依旧位于包含框之内。

相对定位将元素相对于它在普通流中的位置进行定位。

绝对定位是指将元素的内容从普通流中完全移除，并且可以使用偏移属性来固定该元素的位置。

固定定位是指将元素的内容固定在页面的某个位置。
